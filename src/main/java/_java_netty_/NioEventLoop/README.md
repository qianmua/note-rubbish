### [NioEventLoop 的创建](https://github.com/martin-1992/Netty-Notes/tree/master/NioEventLoop/NioEventLoop%20%E7%9A%84%E5%88%9B%E5%BB%BA)
　　服务端启动时会创建两个 group，NioEventLoopGroup 为 NioEventLoop 的数组。NioEventLoopGroup 的构造函数是由父类定义的，从 NioEventLoopGroup -> MultithreadEventLoopGroup -> MultithreadEventExecutorGroup，在 MultithreadEventExecutorGroup 类的 MultithreadEventExecutorGroup 方法实现。

### [NioEventLoop 的启动](https://github.com/martin-1992/Netty-Notes/tree/master/NioEventLoop/NioEventLoop%20%E7%9A%84%E5%90%AF%E5%8A%A8)

- [NioEventLoop#select](https://github.com/martin-1992/Netty-Notes/blob/master/NioEventLoop/NioEventLoop%20%E7%9A%84%E5%90%AF%E5%8A%A8/select()%20%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.md)，检查是否有就绪的感兴趣的 IO 事件。调用 select 方法，轮询注册到 selector 上的 Channel，返回那些感兴趣的已就绪的 IO 事件的 Channel。Netty 会通过阻塞时间长短来判断是否触发空轮询 bug，如果当前阻塞一个 selector 操作，实际没有花这么长时间，有可能触发空轮询 bug，默认情况下，这个现象达到 512 次，则重建一个 selector，把之前 selector 上面所有的 key 重新移交到新的 selector，通过这种方式来避免 JDK 空轮询 bug 的；
- [NioEventLoop#processSelectedKeys](https://github.com/martin-1992/Netty-Notes/blob/master/NioEventLoop/NioEventLoop%20%E7%9A%84%E5%90%AF%E5%8A%A8/processSelectedKeys.md)，通过 JDK 底层 API 获取注册到该 Selector 的所有 Channel 中已就绪的 IO 事件，通过遍历 selectedKeys 处理。如果当前线程为 EventLoop 线程，则直接执行 IO 任务，不会放到任务队列中，通过该方法异步执行 selectionKey 中 ready 的事件，比如 accept、connect、read、write 等。这里不在 EventLoop 线程会直接返回，而在 pipeline 中如果不在 EventLoop 线程，则会使用该线程的线程工厂 Executor 创建一个线程任务放到任务队列中执行；
- [SingleThreadEventExecutora#runAllTasks](https://github.com/martin-1992/Netty-Notes/blob/master/NioEventLoop/NioEventLoop%20%E7%9A%84%E5%90%AF%E5%8A%A8/runAllTasks.md)，该方法有两个，一个不带参数，是执行普通任务队列的任务直到全部任务执行完毕。另一个是带超时时间的方法，**使用时间片方式，来轮询处理 Channel 中的读写事件和任务队列中的事件。** 防止处理任务队列的时间太长，导致没法处理 Channel 中的读写事件。两个方法都会将到指定时间的定时任务添加到普通任务队列中执行，如果当前线程不为 NioEventLoop 线程，则将任务添加到任务队列中执行，比如注册 register0、重建 Selector（解决空轮询 bug），然后调用该方法执行。
