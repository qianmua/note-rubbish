

# jvm

    javap -v
    
    程序指令  
    #指向的是自己的常量池
    
## 虚拟机栈

    栈运行时单位，堆存储的单位
     局部变量表可以放一些数据
     生命周期以线程保持一致
     保存方法的局部变量（8种基本，对象引用地址） 
     部分结果 
     参与方法的调用与返回
     
     
     
     每个线程多有自己的栈
     栈中数据是用栈帧存贮（就是单元就是栈帧frame）
     每个方法对应一个栈帧，栈帧就是一个内存块
     
     
      jvm对java栈的操作只有两个 入栈和出栈，先进后出，后进先出原则
      在一个活动线程中，一个时间点上只会有一个活动的栈，即当前栈帧，当前方法，当前类
      如果调用了其他方法，M那么新的栈帧就会被创建出来，放在栈顶，成为新的栈帧
      每个方法对应一个栈帧
      
      线程之间栈是隔离的
      
      弹出栈帧 -> return和异常都会呆滞栈帧弹出
      
## 栈帧内部结构

    局部变量表
    操作数栈
    动态链接 指向运行时常量池(元空间)的方法引用
    方法返回地址
    附加信息
    
    
## 

     this 不存在static 的方法局部变量表中
     this 在方法变量表第一位
     
     
     局部变量表 ， （本地变量表） 基本储存单元slot 变量槽 32位 占一个槽 64位 占俩
     数组，用域储存方法参数与定义在内部的局部变量 基本数据类型 对象引用 returnAddress
     不存在数据安全问题
     容量大小在编译期确定的，运行期间不会改变大小
     
     slot 重复利用 ，方法里面有代码块，占用位置失效后，它后面的变量会把位置填上，就是重复利用了。、
     
     
>    静态变量与局部变量

    类变量 linking 默认 initial 赋值
    
    实例变量 随着对象创建在堆空间中分配空间进行默认赋值
    
    局部变量 使用前 必须显式的赋值
    
    
     操作数栈 32位一个 64位俩
     
     在方法执行过程中没根据字节码给栈中写入或者提取数据 push  load
     
     
## 栈顶缓存

    将栈顶元素全部缓存在cpu寄存器中降低读写次数，提高效率
    
## 动态链接

    指向运行时的常量池连接，就是#符号引用
    
## new 的时候都发生了什么？

    1、在堆开辟
    2、局部变量表拷贝一份
    3、调用init方法
    new 不是一个线程安全的
    
## return

    恢复指针（局部变量表，操作数栈）
    计数器
    回收内存
    
## 指针压缩 （8字节 未开启压缩 （凯斯4字节））

    
## 对象内存布局

    对象头（MarkWord 8bit , 
    类型指针对象所属Class的地址（就是方法区的模板）(指针压缩的地方8bit) ， 数组长度 ， 对齐填充）
    
    实例数据区(基本类型啥的，类里面的属性)
    对齐填充
    
## OOP 和oop 一个面向对象 一个对象地址
    
    指针压缩将地址后面的空0 （3个）去掉
    用的时候&<<3 补齐
    一个oop能表示的最大堆空间是？
    2^35次方 4字节 + 3
    
## 为什么是8字节对齐不是16字节对齐？
    
    浪费空间了。。
    方便操作

## 虚拟机栈最小160k

    栈深度772
    个栈帧大小约等于 160 * 1024 / 772 ~= 200b
    
    