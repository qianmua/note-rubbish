<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <div style="width: 200px ; height: 200px; border: 1px solid red;" id="div"></div>
</body>

<script>
    var byId = document.getElementById("div");
    byId.addEventListener( 'click' , function() {
        setTimeout( () => {
            this.style.background = 'pink'
        }, 2000)
    } )



    const res = [1,4,6,7,89,9,6,3]
    console.log( res.filter( v1 => v1%2 === 0 ))

    // 箭头 函数 不适合 事件回调
    // 对象方法
    // this 指向 上一级 作用域
    //

    // 参数 默认值
    //
    let fun1 = (v1=10 , v2=20) => {
        return v1 + v2;
    }

    /// 解构
    function func2({name , v1,v2}){
        console.log(name)
        console.log(v1)
        console.log(v2)
    }
    func2({name:'111' , v1 : '6' , v2: 111})


    //rest 参数
    // 得到 函数的实参 // 代替 arguments

    // 对象
    function d1(){
        console.log(arguments)
    }

    d1('111' , '2222')

    // rest
    // 要放到最后
    // 前面用 ...
    function d2(...args){
        console.log(args)
    }
    // 数组
    // 可以用数组的方法哦
    d2('1' ,2 ,3, 5)


    //扩展运算符
    // ...
    // 就跟 kotlin 解构差不多
    const  arr1 = [1,23,4,5,6,7,8]
    function f() {
        console.log(arguments)
    }
    // 数组 变为 参数
    //
    f(...arr1)


    // 应用
    //
    // 1、 数组 合并
    arr2 = [1,23,4,5]
    arr3 = [5,6,7,8,9]
    // 数组 方法
    let arr4 = arr2.concat(arr3)
    console.log(arr4)
    // 扩展运算符
    let arr5 = [...arr2 , ...arr3]
    console.log(arr4)

    //2、 数组 clone
    // [...arr]

    // 伪数组 转数组
    // 比如 dom树 是一个 object
    var of = [...document.querySelectorAll('div')];
    // 还是 可以用 正常的 操作 的哦
   console.log(of)






</script>
</html>