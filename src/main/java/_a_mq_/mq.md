

# 为什么使用MQ?

    解耦、异步、削峰。
    
缺点有以下几个：

    系统可用性降低
    系统引入的外部依赖越多，越容易挂掉。万一 MQ 挂了，MQ 一挂，整套系统崩溃，你不就完了？
    
    系统复杂度提高
    硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？问题一大堆。
    
    一致性问题
    A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；
    但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。
    
    
## Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么区别？

    吞吐量来说kafka和RocketMQ支撑高吞吐，ActiveMQ和RabbitMQ比他们低一个数量级。
    
    对于延迟量来说RabbitMQ是最低的。
    
    持久化消息比较
        ActiveMq 和RabbitMq 都支持。持久化消息主要是指我们机器在不可抗力因素等情况下挂掉了，消息不会丢失的机制。
        
        
    高并发:
    RabbitMQ 最高，原因是它的实现语言是天生具备高并发高可用的erlang 语言。
    
    
    RabbitMQ 和 Kafka:
    Kafka 的定位主要在日志等方面
    业务方面还是建议选择 RabbitMq 。
    
## 如何保证高可用的？

    RabbitMQ 基于主从（非分布式）做高可用性的
    
    
    RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。
    
    普通：
    每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，
    但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。
    你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。
    这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。
    
    镜像：
     RabbitMQ 的高可用模式。
     跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，
     就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。
     然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。
     RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，
     指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，
     应用这个策略，就会自动将数据同步到其他的节点上去了。
     这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，
     别的 consumer 都可以到其它节点上去消费数据。
     坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！
     RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。
     
     
     
     
     Kafka ：
     
      一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；
      你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，
      每个 partition 就放一部分数据。这就是天然的分布式消息队列
      
      就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。
      Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制。
      每个 partition 的数据都会同步到其它机器上 形成自己的多个 replica 副本。
      所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，
      然后其他 replica 就是 follower。
      写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。
      只能读写 leader？很简单，要是你可以随意读写每个 follower，那么就要 care 数据一致性的问题，
      系统复杂度太高，很容易出问题。
      Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。
      因为如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本的，
      如果这上面有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，
      大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。
      写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。
      一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，
      就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）
      消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。
      
      
## 如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？

    自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。
    
## 如何保证消息的可靠性传输啊？要是消息丢失了怎么办啊？

    生产者丢失：网络等
    RabbitMQ 提供的事务功能
    
    生产者发送数据之前开启 RabbitMQ 事务channel.txSelect，然后发送消息，
    如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，
    然后重试发送消息；
    
    太耗性能
    
    要确保说写 RabbitMQ 的消息别丢，可以开启confirm模式
    
    在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的 id，
    然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个ack消息，告诉你说这个消息 ok 了。
    如果 RabbitMQ 没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。
    
    而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。
    
    事务机制和cnofirm机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，
    但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息
    
    
    MQ中丢失：就是 RabbitMQ 自己弄丢了数据
    
    开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据
    
    
    
    消费端丢失：你消费的时候，刚消费到，还没处理，结果进程挂了
    
    用 RabbitMQ 提供的ack机制，简单来说，就是你关闭 RabbitMQ 的自动ack，
    可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里ack一把。
    这样的话，如果你还没处理完，不就没有ack？
    那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。
    
    
## 如何保证消息顺序性

    顺序会错乱的场景：RabbitMQ：一个 queue，多个 consumer，这不明显乱了；
    
    拆分queuq 一个queue对应一个consumer
    
## 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？

    消息积压处理办法：临时紧急扩容：
    
    
    MQ中消息失效：
    批量重导 将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，
    
    
    mq消息队列块满了：
    
    