# 大纲

![](img/Xnip2019-06-09_20-50-34.jpg)

# 前言

**Java内存模型**(JMM)和**Java运行时数据区**(Java内存结构)是两个概念。

面试的时候，如果 面试官问你Java内存模型，他可能指的是后者(虽然这个可能是他理解错)，为了确保你回答无误，最好向他确认一下是前者还是后者。

# 目标

定义程序中**各个变量**的**访问规则**，即在虚拟机中讲变量**存储到内存**和从内存**取出**变量这样的底层细节

抽象结构如下图所示

![](img/Xnip2019-05-17_22-46-01.jpg)

以下几点需要注意：

- 这里的变量，不是像Java语言中的变量，他不包含**局部变量**和**方法参数**，因为那个是线程私有的，**不共享**
- 线程对变量的操作只能通过**本地内存**(工作内存)，**不能**直接**操作主内存**

# 内存间的交互操作

对于以下8个操作，虚拟机保证必须是原子操作(不可再分的)

- lock(锁定)：作用于**主内存**的变量，把一个变量标示为一个线程独占状态
- unlock(解锁)：作用于**主内存**的变量，他把一个处于**锁定状态**的变量释放出来，**释放后**的变量才可以**被其他线程锁定**
- read(读取)：作用于**主内存**的变量，他把一个变量的值从**主内存**传输到线程的**本地内存**(工作内存)，以便随后的load动作使用
- load(载入)：作用于**工作内存**的变量，把read操作得到的值放入**本地内存**(工作内存)的**变量副本**中
- use(使用)：作用于**工作内存**的变量，把**本地内存**(工作内存)中一个变量的值传递给**执行引擎**(Java线程)。每当**虚拟机**遇到一个需要**使用变量**的**字节码指令**，就执行该操作
- assign(赋值): 作用于**工作内存**的变量，把从**执行引擎**(Java线程)接收到的值赋给**工作内存(**本地内存)。每当**虚拟机**遇到一个给**变量赋值**的字节码指令时执行这个操作
- store(存储)：作用于**工作内存**的变量，把**工作内存**中的一个变量的值传送到**主内存**中，以便后面的write使用
- write(写入)：作用于**主内存**的变量，把store操作从**工作内存**传过来的变量存到**主内存变量**中。

这个流程用图表展示出来是这样

![](img/Xnip2019-05-19_17-27-08.jpg)

## 规则

执行上述8条命令还应该满足一下几个规则：

- 不允许 read和load、store和write操作之一单独出现(如从主内存读到工作内存，但是工作内存不加载进变量）
- 不允许一个线程丢弃他最近的assign操作，（变量在工作内存中改变了之后必须把该变化同步回主内存）
- 不允许线程无原因的(没有进行任何assign)，把数据从工作内存同步到主内存
- 一个新的变量只能在主内存中产生,不允许在工作内存中直接使用一个未被初始化过得变量(load或assign)。
- 一个变量在同一时刻只允许一个线程对其进行lock操作，但变量可以被同一条线程lock多次，并且需要执行相同次数的unlock操作，变量才会解锁
- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前，需要重新执行load或assign操作初始化，变量才会被解锁平
- 如果一个变量没有被lock，那么就不允许unlock操作，也不允许unlock被其他线程lock的变量
- 对一个变量执行unlock前，必须先把此变量同步回主内存中(执行store、write操作)

# 先行并发规则(happens-before)

上面的8个规则，定义严谨，但是实践起来非常麻烦，所以还有一个等效的**先行并发规则**

先行并发规则是判断 **数据是否存在竞争，线程是否安全的主要依据**

## 注意

两个操作之间有先行并发关系，**并不意味着**前面的操作一定在后面的那个操作前执行。它仅要求**前一个操作的结果（如修改共享变量的值，发送了消息，调用了方法等）对后一个可见**，且前一个操作按顺序排在后一个操作之前。



**时间上的先发生，不代表这个操作先行发生；反过来，一个操作先行发生，也不代表这个操作时间上先发生。**

什么意思呢？

假如我们有下面两个代码

```java
// 以下操作在同一个线程中执行
int i = 1;
int j = 2;

```

上面的两条赋值语句在同一个线程中，**根据程序次序规则**，第一条语句`int i= 1` 先行发生与第二条语句。但是第二条语句完全可能先被处理器执行，这并不影响先行发生原则的正确性，因为我们在这个线程中没办法感知这一点

所以这个例子是后面那句，一个操作先行发生，不代表时间上的先发生，也可能处理器先执行后面那句

对于前面那句，我们用这个例子

```java
private int value = 0 ;
public void setValue(int  value){
  this.value = value;
}
public int getValue(){
  return value;
}
```

我们假设有两个线程，线程A和线程B。

线程A先（时间上先后）调用`setValue`函数，然后线程B在调用同一个对象的`getValue`方法，那么他会返回什么值呢？**答案是不确定**，因为他线程不安全啊，他不满足以下的几个规则：



- 程序次序规则：**在一个线程内**，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。当然，更准确的应该是控制流顺序而不是代码顺序，因为还有分支、循环、方法调用
- 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而"后面"指的是时间上的先后顺序
- volatile 变量规则：对一个"volatile"变量的写操作先行发生于后面对这个变量的读操作，这里的"后面"同样指事件上的先后
- 线程启动规则：Thread对象的`start`方法先行发生于此线程的每个动作
- 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过`Thread.join`方法结束、`Thread.isAlive`方法的返回值等方法检测到线程已经终止执行。
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过`Thread.interrupted()`方法检测到是否有中毒那发生
- 对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于他的`finalize()`方法的开始
- 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。

