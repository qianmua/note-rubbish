

# hashmap

## jdk7 hashMap
    
    储存结构 数组加链表
    会把key value 封装为一个entity
    
    
> 思路 : key下标怎么得到？ 得到hashCode % table.length = 就是他的数组下标了

    要是key重复了，那就放到链表中
    
    解决速度插入头部
    
    问题： 怎么get？
    如果插入头部，怎么得到？（链表只有next 没有 prev）
    解决 插入后向下移动一位就行了
    移动 ： 将指针向下移动一个就行了
    
    
    如果index 相等且hashcode也相等，那么覆盖并且返回覆盖之前的value
    
    初始化容量是一个2的n次幂
    初始化的容量很init的 value不只是直接相等的
    
    (init - 1) < 1 然后计算处他里面的最大的 2的N次幂
    
    
    作用：
    hashMap真实算数组的下标
    得到hashcode值 ， 还有容量
    hashcode & (size -1)
    
    即 取得的value在容量范围之内
    
    
    扩容： 最大size : 1 << 30 2^32
    判断已存的大小是否大于这个阈值 (数组大小 * 负载因子)
    并且当前下标没有key（jdk7）
    扩容时会拷贝一份（链表也会拷贝的 （反向的）） 是个双重for （for + while）
    
> 多线程问题

    多线程下要是拷贝的时候会产生循环链表的问题
    线程一二都会拷贝一份
    
    线程一完了，线程二还没完
    
    线程二拷贝的时候，产生循环链表死循环
    
    扩容的目的：
    缩小链表的容量
    
    
    
## java8 使用的是 数组 + node + 红黑树

    resize 扩容
    
    通过四组指针
    
    指针分离去扩容的
    
    
    为什么是2的n次幂?
     因为2的幂-1都是11111结尾的，所以碰撞几率小。
     将二进制进行按位于，(16-1) 是 1111,末位是1，这样也能保证计算后的index既可以是奇数也可以是偶数
     
     不是的话
     增加了碰撞的几率，
     减慢了查询的效率，
     造成空间的浪费。
     
     
     所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，
     那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，
     相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。
     
     
     还是 有点 线程不安全的。
     在扩容的时候 可能会造成 数据丢失哦
     添加数据的时候 刚好正在扩容
     数据 放到原node
     造成数据丢失
     

> put     
     
     HashMap中put方法的过程
     调用哈希函数获取Key对应的hash值，再计算其数组下标
     如果没有出现哈希冲突，则直接放入数组；如果出现哈希冲突，则以链表的方式放在链表后面；
     如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表;
     
     如果结点的key已经存在，则替换其value即可；
     如果集合中的键值对大于12，调用resize方法进行数组扩容
     
     
> get     
     
     .1 通过 hash & (table.length - 1)获取该key对应的数据节点的hash槽;
     .2 判断首节点是否为空, 为空则直接返回空;
     .3 再判断首节点.key 是否和目标值相同, 相同则直接返回(首节点不用区分链表还是红黑树);
     .4 首节点.next为空, 则直接返回空;
     .5 首节点是树形节点, 则进入红黑树数的取值流程, 并返回结果;
     .6 进入链表的取值流程, 并返回结果;

> resize
     
     数组扩容的过程
     创建一个新的数组，其容量为旧数组的两倍，并重新计算旧数组中结点的存储位置。
     结点在新数组中的位置只有两种，原下标位置或原下标+旧数组的大小。
     
     
     
     .1 如果table == null, 则为HashMap的初始化, 生成空table返回即可;
     .2 如果table不为空, 需要重新计算table的长度, newLength = oldLength << 1(注, 如果原oldLength已经到了上限,
      则newLength = oldLength);
     .3 遍历oldTable:
     .3.2 首节点为空, 本次循环结束;
     .3.1 无后续节点, 重新计算hash位, 本次循环结束;
     .3.2 当前是红黑树, 走红黑树的重定位;
     .3.3 当前是链表, JAVA7时还需要重新计算hash位, 但是JAVA8做了优化, 通过(e.hash & oldCap) == 0来判断是否需要移位; 
     如果为真则在原位不动, 否则则需要移动到当前hash槽位 + oldCap的位置;
     
     
> HashTable 

    HashMap 是线程不安全的，HashTable 是线程安全的；
    HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable不允许；
    HashMap 默认初始化数组的大小为16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍+1；
    HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode
    HashTable 是使用 synchronize 关键字加锁
     
     
> ConcurrentHashMap

    ConcurrentHashMap 保证线程安全
    通过 加锁 + cas

    hashMap 可以放空的
    ConcurrentHashMap 不许 放入空 k，v
    
    
    put 时候
    先判断
    然后 cas
    节点无值 直接添加
    有值
    加锁
    
    
    多线程下扩容机制
    对放入的数据 进行 标记
    每个线程不是 自己扩容自己的
    插入的那个线程也会去帮助 扩容 转移数据