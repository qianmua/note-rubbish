

# redis 缓存策略

> Cache-Aside (常用)

    应用程序首先检查缓存。
    
    如果在缓存中找到，表示已经命中缓存。数据被读取并返回给应用程序。
    
    如果在缓存中没有找到，则未命中缓存。
    应用程序必须做一些额外的工作，它需要查询数据库来读取数据，将数据返回给客户端，
    然后还要将数据存储在缓存中，这样对相同数据的后续读取可以命中缓存。
    
    
    适合读多的应用场景
    
    
    缓存可能与数据库不一致
    
    数据预热
    
    
> Read-Though Cache

    Read-though策略下的缓存与数据库保持一致。当缓存丢失时，它从数据库加载相应的数据，填充缓存并将其返回给应用程序
    
    cache-aside和read-through策略都是延迟加载数据的，也就是说，只在第一次读取数据时才加载数据。
    
    关键区别:
    
    在cache-aside中，应用程序负责从数据库中获取数据并填充缓存。在read-through中，此逻辑通常由库或独立缓存提供程序支持
    
    与cache-aside不同，read-through cache中的数据模型不能与数据库中的数据模型不同。
    
    read-through缓存最适合于读量较大的工作负载。
    
    
### 不一致

    写策略
    
> Write-Through Cache

    在这种写策略中，首先将数据写入缓存，然后写入数据库。
    缓存与数据库保持一致，写操作总是通过缓存到达主数据库。
    
    当与read-through结合使用时，我们获得了read-through的所有好处，
    还获得了数据一致性保证，使我们不必使用缓存失效技术。
    
    
    
> Write-Around

    这种策略下，数据直接写入数据库，只有读取的数据才能进入缓存。Write-around可以与read-through结合使用，
    并在数据只写一次、读取次数较少或从不读的情况下提供良好的性能。
    例如，实时日志或聊天室消息。
    同样，这个模式也可以与cache-aside组合使用。
    
> Write-Back
    
    这种策略下，应用程序将数据写入缓存，缓存会立即确认，并在延迟一段时间后将数据写入数据库。
    有时这种策略也被称为write-behind。
    
    Write-back缓存提高了写性能，对于写工作量大的工作负载非常有用。
    