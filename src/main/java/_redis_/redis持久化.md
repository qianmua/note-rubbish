

## 持久化流程

    要有下面五个过程：
    
    1）客户端向服务端发送写操作(数据在客户端的内存中)。
    
    （2）数据库服务端接收到写请求的数据(数据在服务端的内存中)。
    
    （3）服务端调用write这个系统调用，将数据往磁盘上写(数据在系统内存的缓冲区中)。
    
    （4）操作系统将缓冲区中的数据转移到磁盘控制器上(数据在磁盘缓存中)。
    
    （5）磁盘控制器将数据写到磁盘的物理介质中(数据真正落到磁盘上)。
    
    
    Redis数据库发生故障，只要在上面的第三步执行完毕，那么就可以持久化保存，剩下的两步由操作系统替我们完成。
    
    
    
    两种策略机制，也就是RDB和AOF。
    RDB机制：
    
    RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。
    RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。
    也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。
    
    触发机制
    三种机制：save、bgsave、自动化。
    
    
    save触发方式
    该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。
    执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。
    
    bgsave触发方式
    执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。 (fork 进程)
    Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。
    阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。
    
    
    自动触发
    
    自动触发是由我们的配置文件来完成的。在redis.conf配置文件中，里面有如下配置，我们可以去设置：
    
    ①save：这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘
    。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。
    
    
    
    
    RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
    RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。
    
    
    劣势
    
    当进行快照持久化时，会开启一个子进程专门负责快照持久化，
    子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。
    
    
## AOF机制

    redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。
    
    
    文件重写原理
    
    AOF的方式也同时带来了另一个问题。
    持久化文件会变的越来越大。为了压缩aof的持久化文件。
    redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。
    
    
    重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。
    
    
    AOF也有三种触发机制
    
    （1）每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好
    
    （2）每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失
    
    （3）不同no：从不同步
    
    