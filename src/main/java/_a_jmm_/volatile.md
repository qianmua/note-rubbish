


# JMM

## volatile

    voloatile 在底层通过 lock 锁
    // 
    通过汇编的 lock
    //
    就是 在使用处前面加了个 lock
    lock    前缀
    ：
    lock后 会开启  （总线）MESI 缓存一致性协议
    CPU 总线嗅探机制 （监听）
    
    // 
    当线程修改了值 的时候 
    会立即刷新到 主内存中
    
    //
    不会 是等到 线程执行完 在刷新
    //
    通过 总线嗅探，和MESI 监听
    
    //
    内存刷新 有一定的延时
    //
    可能会造成其他 的线程读取不正确
    
    不过汇编 会在 store 之前 加上lock
    让其他线程不能感知
    // 
    知道 值 在内存中确认刷新 才 释放锁
    
>------------

> 主内存 -> read -> 工作内存 -> lock -> store -> write -> 主内存 -> unlock
其他线程 在unlock 后 会 感知 并刷新读取值


### jmm 内存模型

## 并发三特性： 可见性 原子性 有序性

    volatile 保证 可见性 有序性
    
    可见性 ：变量的修改 是对 其他 线程 可见的
    
    原子性 ：俩状态 要么同时 ok ， 要么同时 挂掉
    
> volatile 不保证原子操作  其他线程嗅探到 的时候 可能会丢失

> 被机制 给丢掉了 

