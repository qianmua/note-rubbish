

# 分布式锁

    阻塞锁 ， 标记互斥量 0 1
    
> 数据库唯一索引

    存在问题
        锁没有失效时间 ， 解锁失败其他进程无法获得锁
        不可重入
        
> redis SETEX

    插入成功返回 true ， 存在 返回false ， 可以设置过期时间
    
> redis readLock 算法

> zookeeper 有序节点

    /lock/nde-00001
    /lock/nde-00002
    /lock/nde-00003
    ...
    
    创建 锁目录 /lock
    需要锁 ， 创建临时的有序子节点
    监听是否最小的子节点
    
    会话超时 自动删除临时节点，保证其他线程可以获得锁
    
    羊群效应
    节点只需要监听自己前面一个节点
    


## CAP

    一致性         多个数据副本保持一致
    可用性         对于用户的每一个操作请求总是能够在有限的时间内返回结果。
    分区容错性     在故障时，需要能对外提供一致性和可用性的服务
    
    容错性是必要保证的
    所以：
        要么一致，要么可用 （网络不可靠）
        
        
> BASE 理论

    采用适当的方式 使系统达到最终一致性
    
    基本可用BA：
        分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性
    
    软状态S：
        允许系统不同节点的数据副本之间进行同步的过程存在时延
    
    最终一致性E：
        系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态
        
        
## Paxos

    达成共识，
    算法保证只选出唯一一个值
    
    选举者：[n1 , v1] // 序号 ， 提议值
    投票者：接收之后 返回响应 ， 以后请求 小于n1 序号的直接不接受。
    
    选举者有一半响应之后发送 accept请求 （[n1 , v1]） // 投票者所持有序号大于n1则不接受请求
    ...
    
    
    
> leader
    
    最初没有leader
    所有 follower 指定事件内没有接收到leader 的心跳包 ， 就开始竞选
    
    然后竞选者发送心跳包，有一半回复 则竞选为leader
    
    然后 leader 周期发送心跳包， follower 接收到心跳包，就会重新即时
    
    
    
    多个竞选者时，都会发送心跳包，谁的多谁leader ， 一样 重新竞选
    
    
    数据同步：
        客户端的写入传入给leader ， leader 写入日志，然后复制到所有follower，
        等大多数follower修改后， leader 将修改commit， 然后 leader通知follower 进行commit ， 达成一致性
        
             
    